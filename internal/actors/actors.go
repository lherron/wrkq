package actors

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/lherron/todo/internal/domain"
	"github.com/lherron/todo/internal/id"
)

// parseTime parses a timestamp string into time.Time
func parseTime(s string) (time.Time, error) {
	return time.Parse(time.RFC3339, s)
}

// Resolver handles actor resolution
type Resolver struct {
	db *sql.DB
}

// NewResolver creates a new actor resolver
func NewResolver(db *sql.DB) *Resolver {
	return &Resolver{db: db}
}

// Resolve resolves an actor by slug or friendly ID
// Returns the actor's UUID
func (r *Resolver) Resolve(identifier string) (string, error) {
	if identifier == "" {
		return "", fmt.Errorf("actor identifier cannot be empty")
	}

	// Check if it's a friendly ID
	if id.IsFriendlyID(identifier) {
		return r.resolveByFriendlyID(identifier)
	}

	// Check if it's a UUID
	if id.IsUUID(identifier) {
		return identifier, nil
	}

	// Try to resolve by slug
	return r.resolveBySlug(identifier)
}

// resolveByFriendlyID resolves an actor by friendly ID
func (r *Resolver) resolveByFriendlyID(friendlyID string) (string, error) {
	var uuid string
	err := r.db.QueryRow("SELECT uuid FROM actors WHERE id = ?", friendlyID).Scan(&uuid)
	if err != nil {
		if err == sql.ErrNoRows {
			return "", fmt.Errorf("actor not found: %s", friendlyID)
		}
		return "", fmt.Errorf("failed to resolve actor: %w", err)
	}
	return uuid, nil
}

// resolveBySlug resolves an actor by slug
func (r *Resolver) resolveBySlug(slug string) (string, error) {
	var uuid string
	err := r.db.QueryRow("SELECT uuid FROM actors WHERE slug = ?", slug).Scan(&uuid)
	if err != nil {
		if err == sql.ErrNoRows {
			return "", fmt.Errorf("actor not found: %s", slug)
		}
		return "", fmt.Errorf("failed to resolve actor: %w", err)
	}
	return uuid, nil
}

// GetByUUID gets an actor by UUID
func (r *Resolver) GetByUUID(uuid string) (*domain.Actor, error) {
	actor := &domain.Actor{}
	var createdAt, updatedAt string
	err := r.db.QueryRow(`
		SELECT uuid, id, slug, display_name, role, meta, created_at, updated_at
		FROM actors WHERE uuid = ?
	`, uuid).Scan(
		&actor.UUID, &actor.ID, &actor.Slug, &actor.DisplayName,
		&actor.Role, &actor.Meta, &createdAt, &updatedAt,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("actor not found: %s", uuid)
		}
		return nil, fmt.Errorf("failed to get actor: %w", err)
	}

	actor.CreatedAt, err = parseTime(createdAt)
	if err != nil {
		return nil, fmt.Errorf("failed to parse created_at: %w", err)
	}
	actor.UpdatedAt, err = parseTime(updatedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to parse updated_at: %w", err)
	}

	return actor, nil
}

// GetBySlug gets an actor by slug
func (r *Resolver) GetBySlug(slug string) (*domain.Actor, error) {
	actor := &domain.Actor{}
	var createdAt, updatedAt string
	err := r.db.QueryRow(`
		SELECT uuid, id, slug, display_name, role, meta, created_at, updated_at
		FROM actors WHERE slug = ?
	`, slug).Scan(
		&actor.UUID, &actor.ID, &actor.Slug, &actor.DisplayName,
		&actor.Role, &actor.Meta, &createdAt, &updatedAt,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("actor not found: %s", slug)
		}
		return nil, fmt.Errorf("failed to get actor: %w", err)
	}

	actor.CreatedAt, err = parseTime(createdAt)
	if err != nil {
		return nil, fmt.Errorf("failed to parse created_at: %w", err)
	}
	actor.UpdatedAt, err = parseTime(updatedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to parse updated_at: %w", err)
	}

	return actor, nil
}

// List lists all actors
func (r *Resolver) List() ([]*domain.Actor, error) {
	rows, err := r.db.Query(`
		SELECT uuid, id, slug, display_name, role, meta, created_at, updated_at
		FROM actors ORDER BY created_at DESC
	`)
	if err != nil {
		return nil, fmt.Errorf("failed to list actors: %w", err)
	}
	defer rows.Close()

	var actors []*domain.Actor
	for rows.Next() {
		actor := &domain.Actor{}
		var createdAt, updatedAt string
		err := rows.Scan(
			&actor.UUID, &actor.ID, &actor.Slug, &actor.DisplayName,
			&actor.Role, &actor.Meta, &createdAt, &updatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan actor: %w", err)
		}

		actor.CreatedAt, err = parseTime(createdAt)
		if err != nil {
			return nil, fmt.Errorf("failed to parse created_at: %w", err)
		}
		actor.UpdatedAt, err = parseTime(updatedAt)
		if err != nil {
			return nil, fmt.Errorf("failed to parse updated_at: %w", err)
		}

		actors = append(actors, actor)
	}

	return actors, nil
}

// Create creates a new actor
func (r *Resolver) Create(slug, displayName, role string) (*domain.Actor, error) {
	tx, err := r.db.Begin()
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Insert actor (UUID and friendly ID are generated by triggers)
	result, err := tx.Exec(`
		INSERT INTO actors (id, slug, display_name, role)
		VALUES ('', ?, ?, ?)
	`, slug, displayName, role)
	if err != nil {
		return nil, fmt.Errorf("failed to create actor: %w", err)
	}

	// Get the UUID of the created actor
	rowID, err := result.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("failed to get last insert ID: %w", err)
	}

	// Fetch the created actor
	actor := &domain.Actor{}
	var createdAt, updatedAt string
	err = tx.QueryRow(`
		SELECT uuid, id, slug, display_name, role, meta, created_at, updated_at
		FROM actors WHERE rowid = ?
	`, rowID).Scan(
		&actor.UUID, &actor.ID, &actor.Slug, &actor.DisplayName,
		&actor.Role, &actor.Meta, &createdAt, &updatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get created actor: %w", err)
	}

	// Parse timestamps
	actor.CreatedAt, err = parseTime(createdAt)
	if err != nil {
		return nil, fmt.Errorf("failed to parse created_at: %w", err)
	}
	actor.UpdatedAt, err = parseTime(updatedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to parse updated_at: %w", err)
	}

	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return actor, nil
}
